---
title: "9.7.18.2. SIMD Video Instructions"
section: 9.7.18.2
url: https://docs.nvidia.com/cuda/parallel-thread-execution/
---

#### 9.7.18.2. SIMD Video Instructions


The SIMD video instructions operate on pairs of 16-bit values and quads of 8-bit values.

The SIMD video instructions are:

* `vadd2`, `vadd4`

  * `vsub2`, `vsub4`

  * `vavrg2`, `vavrg4`

  * `vabsdiff2`, `vabsdiff4`

  * `vmin2`, `vmin4`

  * `vmax2`, `vmax4`

  * `vset2`, `vset4`

PTX includes SIMD video instructions for operation on pairs of 16-bit values and quads of 8-bit values. The SIMD video instructions execute the following stages:

1. Form input vectors by extracting and sign- or zero-extending byte or half-word values from the source operands, to form pairs of signed 17-bit values.

  2. Perform a SIMD arithmetic operation on the input pairs.

  3. Optionally clamp the result to the appropriate signed or unsigned range, as determinted by the destination type.

  4. Optionally perform one of the following:

     1. perform a second SIMD merge operation, or

     2. apply a scalar accumulate operation to reduce the intermediate SIMD results to a single scalar.

The general format of dual half-word SIMD video instructions is as follows:

// 2-way SIMD operation, with second SIMD merge or accumulate
    vop2.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;
    
    .dtype = .atype = .btype = { .u32, .s32 };
    .mask  = { .h0, .h1, .h10 };
    .asel  = .bsel = { .hxy, where x,y are from { 0, 1, 2, 3 } };

The general format of quad byte SIMD video instructions is as follows:

// 4-way SIMD operation, with second SIMD merge or accumulate
    vop4.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;
    
    .dtype = .atype = .btype = { .u32, .s32 };
    .mask  = { .b0,
               .b1, .b10
               .b2, .b20, .b21, .b210,
               .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
    .asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };

The source and destination operands are all 32-bit registers. The type of each operand (`.u32` or `.s32`) is specified in the instruction type; all combinations of `dtype`, `atype`, and `btype` are valid. Using the `atype/btype` and `asel/bsel` specifiers, the input values are extracted and sign- or zero-extended internally to `.s33` values. The primary operation is then performed to produce an `.s34` intermediate result. The sign of the intermediate result depends on `dtype`.

The intermediate result is optionally clamped to the range of the destination type (signed or unsigned), taking into account the subword destination size in the case of optional data merging.

#####  9.7.18.2.1. [SIMD Video Instructions: `vadd2`, `vsub2`, `vavrg2`, `vabsdiff2`, `vmin2`, `vmax2`](<#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2>)

`vadd2`, `vsub2`

Integer dual half-word SIMD addition/subtraction.

`vavrg2`

Integer dual half-word SIMD average.

`vabsdiff2`

Integer dual half-word SIMD absolute value of difference.

`vmin2`, `vmax2`

Integer dual half-word SIMD minimum/maximum.

Syntax
    
    
    // SIMD instruction with secondary SIMD merge operation
    vop2.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;
    
    // SIMD instruction with secondary accumulate operation
    vop2.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;
    
     vop2  = { vadd2, vsub2, vavrg2, vabsdiff2, vmin2, vmax2 };
    .dtype = .atype = .btype = { .u32, .s32 };
    .mask  = { .h0, .h1, .h10 };  // defaults to .h10
    .asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };
       .asel defaults to .h10
       .bsel defaults to .h32
    

Description

Two-way SIMD parallel arithmetic operation with secondary operation.

Elements of each dual half-word source to the operation are selected from any of the four half-words in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected half-words are then operated on in parallel.

The results are optionally clamped to the appropriate range determined by the destination type (signed or unsigned). Saturation cannot be used with the secondary accumulate operation.

For instructions with a secondary SIMD merge operation:

  * For half-word positions indicated in mask, the selected half-word results are copied into destination `d`. For all other positions, the corresponding half-word from source operand `c` is copied to `d`.


For instructions with a secondary accumulate operation:

  * For half-word positions indicated in mask, the selected half-word results are added to operand `c`, producing a result in `d`.


Semantics
    
    
    // extract pairs of half-words and sign- or zero-extend
    // based on operand type
    Va = extractAndSignExt_2( a, b, .asel, .atype );
    Vb = extractAndSignExt_2( a, b, .bsel, .btype );
    Vc = extractAndSignExt_2( c );
    
    for (i=0; i<2; i++) {
        switch ( vop2 ) {
           case vadd2:             t[i] = Va[i] + Vb[i];
           case vsub2:             t[i] = Va[i] - Vb[i];
           case vavrg2:            if ( ( Va[i] + Vb[i] ) >= 0 ) {
                                       t[i] = ( Va[i] + Vb[i] + 1 ) >> 1;
                                   } else {
                                       t[i] = ( Va[i] + Vb[i] ) >> 1;
                                   }
           case vabsdiff2:         t[i] = | Va[i] - Vb[i] |;
           case vmin2:             t[i] = MIN( Va[i], Vb[i] );
           case vmax2:             t[i] = MAX( Va[i], Vb[i] );
        }
        if (.sat) {
            if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S16_MAX, S16_MIN );
            else                   t[i] = CLAMP( t[i], U16_MAX, U16_MIN );
        }
    }
    // secondary accumulate or SIMD merge
    mask = extractMaskBits( .mask );
    if (.add) {
        d = c;
        for (i=0; i<2; i++) {  d += mask[i] ? t[i] : 0;  }
    } else {
        d = 0;
        for (i=0; i<2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
    }
    

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vadd2`, `vsub2`, `varvg2`, `vabsdiff2`, `vmin2`, `vmax2` require `sm_30` or higher.

Examples
    
    
    vadd2.s32.s32.u32.sat  r1, r2, r3, r1;
    vsub2.s32.s32.s32.sat  r1.h0, r2.h10, r3.h32, r1;
    vmin2.s32.u32.u32.add  r1.h10, r2.h00, r3.h22, r1;

#####  9.7.18.2.2. [SIMD Video Instructions: `vset2`](<#simd-video-instructions-vset2>)

`vset2`

Integer dual half-word SIMD comparison.

Syntax
    
    
    // SIMD instruction with secondary SIMD merge operation
    vset2.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;
    
    // SIMD instruction with secondary accumulate operation
    vset2.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;
    
    .atype = .btype = { .u32, .s32 };
    .cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
    .mask  = { .h0, .h1, .h10 };  // defaults to .h10
    .asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };
       .asel defaults to .h10
       .bsel defaults to .h32
    

Description

Two-way SIMD parallel comparison with secondary operation.

Elements of each dual half-word source to the operation are selected from any of the four half-words in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected half-words are then compared in parallel.

The intermediate result of the comparison is always unsigned, and therefore the half-words of destination `d` and operand `c` are also unsigned.

For instructions with a secondary SIMD merge operation:

  * For half-word positions indicated in mask, the selected half-word results are copied into destination `d`. For all other positions, the corresponding half-word from source operand `b` is copied to `d`.


For instructions with a secondary accumulate operation:

  * For half-word positions indicated in mask, the selected half-word results are added to operand `c`, producing `a` result in `d`.


Semantics
    
    
    // extract pairs of half-words and sign- or zero-extend
    // based on operand type
    Va = extractAndSignExt_2( a, b, .asel, .atype );
    Vb = extractAndSignExt_2( a, b, .bsel, .btype );
    Vc = extractAndSignExt_2( c );
    for (i=0; i<2; i++) {
        t[i] = compare( Va[i], Vb[i], .cmp ) ? 1 : 0;
    }
    // secondary accumulate or SIMD merge
    mask = extractMaskBits( .mask );
    if (.add) {
        d = c;
        for (i=0; i<2; i++) {  d += mask[i] ? t[i] : 0;  }
    } else {
        d = 0;
        for (i=0; i<2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
    }
    

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vset2` requires `sm_30` or higher.

Examples
    
    
    vset2.s32.u32.lt      r1, r2, r3, r0;
    vset2.u32.u32.ne.add  r1, r2, r3, r0;

#####  9.7.18.2.3. [SIMD Video Instructions: `vadd4`, `vsub4`, `vavrg4`, `vabsdiff4`, `vmin4`, `vmax4`](<#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4>)

`vadd4`, `vsub4`

Integer quad byte SIMD addition/subtraction.

`vavrg4`

Integer quad byte SIMD average.

`vabsdiff4`

Integer quad byte SIMD absolute value of difference.

`vmin4`, `vmax4`

Integer quad byte SIMD minimum/maximum.

Syntax
    
    
    // SIMD instruction with secondary SIMD merge operation
    vop4.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;
    
    // SIMD instruction with secondary accumulate operation
    vop4.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;
    vop4  = { vadd4, vsub4, vavrg4, vabsdiff4, vmin4, vmax4 };
    
    .dtype = .atype = .btype = { .u32, .s32 };
    .mask  = { .b0,
               .b1, .b10
               .b2, .b20, .b21, .b210,
               .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
        defaults to .b3210
    .asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
       .asel defaults to .b3210
       .bsel defaults to .b7654
    

Description

Four-way SIMD parallel arithmetic operation with secondary operation.

Elements of each quad byte source to the operation are selected from any of the eight bytes in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected bytes are then operated on in parallel.

The results are optionally clamped to the appropriate range determined by the destination type (signed or unsigned). Saturation cannot be used with the secondary accumulate operation.

For instructions with a secondary SIMD merge operation:

  * For byte positions indicated in mask, the selected byte results are copied into destination `d`. For all other positions, the corresponding byte from source operand `c` is copied to `d`.


For instructions with a secondary accumulate operation:

  * For byte positions indicated in mask, the selected byte results are added to operand `c`, producing a result in `d`.


Semantics
    
    
    // extract quads of bytes and sign- or zero-extend
    // based on operand type
    Va = extractAndSignExt_4( a, b, .asel, .atype );
    Vb = extractAndSignExt_4( a, b, .bsel, .btype );
    Vc = extractAndSignExt_4( c );
    for (i=0; i<4; i++) {
        switch ( vop4 ) {
            case vadd4:            t[i] = Va[i] + Vb[i];
            case vsub4:            t[i] = Va[i] - Vb[i];
            case vavrg4:           if ( ( Va[i] + Vb[i] ) >= 0 ) {
                                       t[i] = ( Va[i] + Vb[i] + 1 ) >> 1;
                                   } else {
                                       t[i] = ( Va[i] + Vb[i] ) >> 1;
                                   }
            case vabsdiff4:        t[i] = | Va[i] - Vb[i] |;
            case vmin4:            t[i] = MIN( Va[i], Vb[i] );
            case vmax4:            t[i] = MAX( Va[i], Vb[i] );
        }
        if (.sat) {
            if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S8_MAX, S8_MIN );
            else                   t[i] = CLAMP( t[i], U8_MAX, U8_MIN );
        }
    }
    // secondary accumulate or SIMD merge
    mask = extractMaskBits( .mask );
    if (.add) {
        d = c;
        for (i=0; i<4; i++) {  d += mask[i] ? t[i] : 0;  }
    } else {
        d = 0;
        for (i=0; i<4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
    }
    

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vadd4`, `vsub4`, `varvg4`, `vabsdiff4`, `vmin4`, `vmax4` require `sm_30` or higher.

Examples
    
    
    vadd4.s32.s32.u32.sat  r1, r2, r3, r1;
    vsub4.s32.s32.s32.sat  r1.b0, r2.b3210, r3.b7654, r1;
    vmin4.s32.u32.u32.add  r1.b00, r2.b0000, r3.b2222, r1;

#####  9.7.18.2.4. [SIMD Video Instructions: `vset4`](<#simd-video-instructions-vset4>)

`vset4`

Integer quad byte SIMD comparison.

Syntax
    
    
    // SIMD instruction with secondary SIMD merge operation
    vset4.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;
    
    // SIMD instruction with secondary accumulate operation
    vset4.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;
    
    .atype = .btype = { .u32, .s32 };
    .cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
    .mask  = { .b0,
               .b1, .b10
               .b2, .b20, .b21, .b210,
               .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
        defaults to .b3210
    .asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
       .asel defaults to .b3210
       .bsel defaults to .b7654
    

Description

Four-way SIMD parallel comparison with secondary operation.

Elements of each quad byte source to the operation are selected from any of the eight bytes in the two source operands `a` and `b` using the `asel` and `bsel` modifiers.

The selected bytes are then compared in parallel.

The intermediate result of the comparison is always unsigned, and therefore the bytes of destination `d` and operand `c` are also unsigned.

For instructions with a secondary SIMD merge operation:

  * For byte positions indicated in mask, the selected byte results are copied into destination `d`. For all other positions, the corresponding byte from source operand `b` is copied to `d`.


For instructions with a secondary accumulate operation:

  * For byte positions indicated in mask, the selected byte results are added to operand `c`, producing a result in `d`.


Semantics
    
    
    // extract quads of bytes and sign- or zero-extend
    // based on operand type
    Va = extractAndSignExt_4( a, b, .asel, .atype );
    Vb = extractAndSignExt_4( a, b, .bsel, .btype );
    Vc = extractAndSignExt_4( c );
    for (i=0; i<4; i++) {
        t[i] = compare( Va[i], Vb[i], cmp ) ? 1 : 0;
    }
    // secondary accumulate or SIMD merge
    mask = extractMaskBits( .mask );
    if (.add) {
        d = c;
        for (i=0; i<4; i++) {  d += mask[i] ? t[i] : 0;  }
    } else {
        d = 0;
        for (i=0; i<4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
    }
    

PTX ISA Notes

Introduced in PTX ISA version 3.0.

Target ISA Notes

`vset4` requires `sm_30` or higher.

Examples
    
    
    vset4.s32.u32.lt      r1, r2, r3, r0;
    vset4.u32.u32.ne.max  r1, r2, r3, r0;