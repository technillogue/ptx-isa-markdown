---
title: "9.7.18.1. Scalar Video Instructions"
section: 9.7.18.1
url: https://docs.nvidia.com/cuda/parallel-thread-execution/
---

#### 9.7.18.1. Scalar Video Instructions


All scalar video instructions operate on 32-bit register operands. The scalar video instructions are:

* `vadd`

  * `vsub`

  * `vabsdiff`

  * `vmin`

  * `vmax`

  * `vshl`

  * `vshr`

  * `vmad`

  * `vset`

The scalar video instructions execute the following stages:

1. Extract and sign- or zero-extend byte, half-word, or word values from its source operands, to produce signed 33-bit input values.

  2. Perform a scalar arithmetic operation to produce a signed 34-bit result.

  3. Optionally clamp the result to the range of the destination type.

  4. Optionally perform one of the following:

     * apply a second operation to the intermediate result and a third operand, or

     * truncate the intermediate result to a byte or half-word value and merge into a specified position in the third operand to produce the final result.

The general format of scalar video instructions is as follows:

// 32-bit scalar operation, with optional secondary operation
    vop.dtype.atype.btype{.sat}        d, a{.asel}, b{.bsel};
    vop.dtype.atype.btype{.sat}.secop  d, a{.asel}, b{.bsel}, c;
    
    // 32-bit scalar operation, with optional data merge
    vop.dtype.atype.btype{.sat}   d.dsel, a{.asel}, b{.bsel}, c;
    
    
    .dtype = .atype = .btype = { .u32, .s32 };
    .dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
    .secop = { .add, .min, .max };

The source and destination operands are all 32-bit registers. The type of each operand (`.u32` or `.s32`) is specified in the instruction type; all combinations of `dtype`, `atype`, and `btype` are valid. Using the `atype/btype` and `asel/bsel` specifiers, the input values are extracted and sign- or zero-extended internally to `.s33` values. The primary operation is then performed to produce an `.s34` intermediate result. The sign of the intermediate result depends on dtype.

The intermediate result is optionally clamped to the range of the destination type (signed or unsigned), taking into account the subword destination size in the case of optional data merging.

.s33 optSaturate( .s34 tmp, Bool sat, Bool sign, Modifier dsel ) {
        if ( !sat )  return tmp;
    
        switch ( dsel ) {
            case .b0, .b1, .b2, .b3:
                if ( sign )  return CLAMP( tmp, S8_MAX, S8_MIN );
                else         return CLAMP( tmp, U8_MAX, U8_MIN );
            case .h0, .h1:
                if ( sign )  return CLAMP( tmp, S16_MAX, S16_MIN );
                else         return CLAMP( tmp, U16_MAX, U16_MIN );
            default:
                if ( sign )  return CLAMP( tmp, S32_MAX, S32_MIN );
                else         return CLAMP( tmp, U32_MAX, U32_MIN );
        }
    }

This intermediate result is then optionally combined with the third source operand using a secondary arithmetic operation or subword data merge, as shown in the following pseudocode. The sign of the third operand is based on `dtype`.

.s33 optSecOp(Modifier secop, .s33 tmp, .s33 c) {
        switch ( secop ) {
            .add:     return tmp + c;
            .min:     return MIN(tmp, c);
            .max      return MAX(tmp, c);
            default:  return tmp;
        }
    }

.s33 optMerge( Modifier dsel, .s33 tmp, .s33 c ) {
        switch ( dsel ) {
            case .h0:  return ((tmp & 0xffff)        | (0xffff0000 & c);
            case .h1:  return ((tmp & 0xffff) << 16) | (0x0000ffff & c);
            case .b0:  return ((tmp & 0xff)          | (0xffffff00 & c);
            case .b1:  return ((tmp & 0xff) <<  8)   | (0xffff00ff & c);
            case .b2:  return ((tmp & 0xff) << 16)   | (0xff00ffff & c);
            case .b3:  return ((tmp & 0xff) << 24)   | (0x00ffffff & c);
            default:   return tmp;
        }
    }

The lower 32-bits are then written to the destination operand.

#####  9.7.18.1.1. [Scalar Video Instructions: `vadd`, `vsub`, `vabsdiff`, `vmin`, `vmax`](<#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax>)

`vadd`, `vsub`

Integer byte/half-word/word addition/subtraction.

`vabsdiff`

Integer byte/half-word/word absolute value of difference.

`vmin`, `vmax`

Integer byte/half-word/word minimum/maximum.

Syntax
    
    
    // 32-bit scalar operation, with optional secondary operation
    vop.dtype.atype.btype{.sat}       d, a{.asel}, b{.bsel};
    vop.dtype.atype.btype{.sat}.op2   d, a{.asel}, b{.bsel}, c;
    
    // 32-bit scalar operation, with optional data merge
    vop.dtype.atype.btype{.sat}  d.dsel, a{.asel}, b{.bsel}, c;
    
     vop   = { vadd, vsub, vabsdiff, vmin, vmax };
    .dtype = .atype = .btype = { .u32, .s32 };
    .dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
    .op2   = { .add, .min, .max };
    

Description

Perform scalar arithmetic operation with optional saturate, and optional secondary arithmetic operation or subword data merge.

Semantics
    
    
    // extract byte/half-word/word and sign- or zero-extend
    // based on source operand type
    ta = partSelectSignExtend( a, atype, asel );
    tb = partSelectSignExtend( b, btype, bsel );
    
    switch ( vop ) {
        case vadd:     tmp = ta + tb;
        case vsub:     tmp = ta - tb;
        case vabsdiff: tmp = | ta - tb |;
        case vmin:     tmp = MIN( ta, tb );
        case vmax:     tmp = MAX( ta, tb );
    }
    // saturate, taking into account destination type and merge operations
    tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );
    d = optSecondaryOp( op2, tmp, c );  // optional secondary operation
    d = optMerge( dsel, tmp, c );       // optional merge with c operand
    

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vadd`, `vsub`, `vabsdiff`, `vmin`, `vmax` require `sm_20` or higher.

Examples
    
    
    vadd.s32.u32.s32.sat      r1, r2.b0, r3.h0;
    vsub.s32.s32.u32.sat      r1, r2.h1, r3.h1;
    vabsdiff.s32.s32.s32.sat  r1.h0, r2.b0, r3.b2, c;
    vmin.s32.s32.s32.sat.add  r1, r2, r3, c;

#####  9.7.18.1.2. [Scalar Video Instructions: `vshl`, `vshr`](<#scalar-video-instructions-vshl-vshr>)

`vshl`, `vshr`

Integer byte/half-word/word left/right shift.

Syntax
    
    
    // 32-bit scalar operation, with optional secondary operation
    vop.dtype.atype.u32{.sat}.mode       d, a{.asel}, b{.bsel};
    vop.dtype.atype.u32{.sat}.mode.op2   d, a{.asel}, b{.bsel}, c;
    
    // 32-bit scalar operation, with optional data merge
    vop.dtype.atype.u32{.sat}.mode  d.dsel, a{.asel}, b{.bsel}, c;
    
     vop   = { vshl, vshr };
    .dtype = .atype = { .u32, .s32 };
    .mode  = { .clamp, .wrap };
    .dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
    .op2   = { .add, .min, .max };
    

Description

`vshl`
    

Shift `a` left by unsigned amount in `b` with optional saturate, and optional secondary arithmetic operation or subword data merge. Left shift fills with zero.

`vshr`
    

Shift `a` right by unsigned amount in `b` with optional saturate, and optional secondary arithmetic operation or subword data merge. Signed shift fills with the sign bit, unsigned shift fills with zero.

Semantics
    
    
    // extract byte/half-word/word and sign- or zero-extend
    // based on source operand type
    ta = partSelectSignExtend( a,atype, asel );
    tb = partSelectSignExtend( b, .u32, bsel );
    if ( mode == .clamp  && tb > 32 )  tb = 32;
    if ( mode == .wrap )                       tb = tb & 0x1f;
    switch ( vop ){
       case vshl:  tmp = ta << tb;
       case vshr:  tmp = ta >> tb;
    }
    // saturate, taking into account destination type and merge operations
    tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );
    d = optSecondaryOp( op2, tmp, c );  // optional secondary operation
    d = optMerge( dsel, tmp, c );       // optional merge with c operand
    

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vshl`, `vshr` require `sm_20` or higher.

Examples
    
    
    vshl.s32.u32.u32.clamp  r1, r2, r3;
    vshr.u32.u32.u32.wrap   r1, r2, r3.h1;

#####  9.7.18.1.3. [Scalar Video Instructions: `vmad`](<#scalar-video-instructions-vmad>)

`vmad`

Integer byte/half-word/word multiply-accumulate.

Syntax
    
    
    // 32-bit scalar operation
    vmad.dtype.atype.btype{.sat}{.scale}     d, {-}a{.asel}, {-}b{.bsel},
                                             {-}c;
    vmad.dtype.atype.btype.po{.sat}{.scale}  d, a{.asel}, b{.bsel}, c;
    
    .dtype = .atype = .btype = { .u32, .s32 };
    .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
    .scale = { .shr7, .shr15 };
    

Description

Calculate `(a*b) + c`, with optional operand negates, _plus one_ mode, and scaling.

The source operands support optional negation with some restrictions. Although PTX syntax allows separate negation of the `a` and `b` operands, internally this is represented as negation of the product `(a*b)`. That is, `(a*b)` is negated if and only if exactly one of `a` or `b` is negated. PTX allows negation of either `(a*b)` or `c`.

The plus one mode (`.po`) computes `(a*b) + c + 1`, which is used in computing averages. Source operands may not be negated in `.po` mode.

The intermediate result of `(a*b)` is unsigned if atype and btype are unsigned and the product `(a*b)` is not negated; otherwise, the intermediate result is signed. Input `c` has the same sign as the intermediate result.

The final result is unsigned if the intermediate result is unsigned and `c` is not negated.

Depending on the sign of the `a` and `b` operands, and the operand negates, the following combinations of operands are supported for VMAD:
    
    
     (u32 * u32) + u32  // intermediate unsigned; final unsigned
    -(u32 * u32) + s32  // intermediate   signed; final   signed
     (u32 * u32) - u32  // intermediate unsigned; final   signed
     (u32 * s32) + s32  // intermediate   signed; final   signed
    -(u32 * s32) + s32  // intermediate   signed; final   signed
     (u32 * s32) - s32  // intermediate   signed; final   signed
     (s32 * u32) + s32  // intermediate   signed; final   signed
    -(s32 * u32) + s32  // intermediate   signed; final   signed
     (s32 * u32) - s32  // intermediate   signed; final   signed
     (s32 * s32) + s32  // intermediate   signed; final   signed
    -(s32 * s32) + s32  // intermediate   signed; final   signed
     (s32 * s32) - s32  // intermediate   signed; final   signed
    

The intermediate result is optionally scaled via right-shift; this result is sign-extended if the final result is signed, and zero-extended otherwise.

The final result is optionally saturated to the appropriate 32-bit range based on the type (signed or unsigned) of the final result.

Semantics
    
    
    // extract byte/half-word/word and sign- or zero-extend
    // based on source operand type
    ta = partSelectSignExtend( a, atype, asel );
    tb = partSelectSignExtend( b, btype, bsel );
    signedFinal = isSigned(atype) || isSigned(btype) ||
                                     (a.negate ^ b.negate) || c.negate;
    tmp[127:0] = ta * tb;
    
    lsb = 0;
    if ( .po )                  {              lsb = 1; } else
    if ( a.negate ^ b.negate )  { tmp = ~tmp;  lsb = 1; } else
    if ( c.negate )             { c   = ~c;    lsb = 1; }
    
    c128[127:0] = (signedFinal) sext32( c ) : zext ( c );
    tmp = tmp + c128 + lsb;
    switch( scale ) {
       case .shr7:   result = (tmp >>  7) & 0xffffffffffffffff;
       case .shr15:  result = (tmp >> 15) & 0xffffffffffffffff;
    }
    if ( .sat ) {
         if (signedFinal) result = CLAMP(result, S32_MAX, S32_MIN);
         else             result = CLAMP(result, U32_MAX, U32_MIN);
    }
    

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vmad` requires `sm_20` or higher.

Examples
    
    
    vmad.s32.s32.u32.sat    r0, r1, r2, -r3;
    vmad.u32.u32.u32.shr15  r0, r1.h0, r2.h0, r3;

#####  9.7.18.1.4. [Scalar Video Instructions: `vset`](<#scalar-video-instructions-vset>)

`vset`

Integer byte/half-word/word comparison.

Syntax
    
    
    // 32-bit scalar operation, with optional secondary operation
    vset.atype.btype.cmp       d, a{.asel}, b{.bsel};
    vset.atype.btype.cmp.op2   d, a{.asel}, b{.bsel}, c;
    
    // 32-bit scalar operation, with optional data merge
    vset.atype.btype.cmp  d.dsel, a{.asel}, b{.bsel}, c;
    
    .atype = .btype = { .u32, .s32 };
    .cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
    .dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
    .op2   = { .add, .min, .max };
    

Description

Compare input values using specified comparison, with optional secondary arithmetic operation or subword data merge.

The intermediate result of the comparison is always unsigned, and therefore destination `d` and operand `c` are also unsigned.

Semantics
    
    
    // extract byte/half-word/word and sign- or zero-extend
    // based on source operand type
    ta = partSelectSignExtend( a, atype, asel );
    tb = partSelectSignExtend( b, btype, bsel );
    tmp = compare( ta, tb, cmp ) ? 1 : 0;
    d = optSecondaryOp( op2, tmp, c );    // optional secondary operation
    d = optMerge( dsel, tmp, c );         // optional merge with c operand
    

PTX ISA Notes

Introduced in PTX ISA version 2.0.

Target ISA Notes

`vset` requires `sm_20` or higher.

Examples
    
    
    vset.s32.u32.lt    r1, r2, r3;
    vset.u32.u32.ne    r1, r2, r3.h1;